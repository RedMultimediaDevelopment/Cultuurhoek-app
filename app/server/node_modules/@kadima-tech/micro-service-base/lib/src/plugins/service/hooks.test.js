"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const jsonwebtoken_1 = __importDefault(require("jsonwebtoken"));
const hooks_1 = require("./hooks");
const token = jsonwebtoken_1.default.sign({
    sub: 'test',
    roles: [],
}, 'SOME_SECRET');
describe('Setup Context Hooks', () => {
    it('Should create a context based on the provided header', async () => {
        const req = {
            headers: {
                authorization: `Bearer ${token}`,
            },
        };
        await (0, hooks_1.injectContextHook)(req, {});
        expect(req.userContext.userId).toBe('test');
        expect(req.getContext).toBeDefined();
        expect(req.getContext()).toBe(req.userContext);
    });
    it('Should default to the anonymous context if no authorization header was provider', async () => {
        const req = {
            headers: {},
        };
        await (0, hooks_1.injectContextHook)(req, {});
        expect(req.userContext.isAuthorizedUser()).toBeFalsy();
    });
});
describe('Response Hooks', () => {
    it.each([204, 302, 400, 404, 500])('Should reply with no content if status code is %i', async (statusCode) => {
        const req = {};
        const reply = {
            statusCode,
        };
        const inputBody = undefined;
        const response = await (0, hooks_1.formatResponseHook)(req, reply, inputBody);
        expect(response).toBe(undefined);
    });
    it('Should reply with a formatted object response', async () => {
        const req = {
            protocol: 'http',
            hostname: 'localhost',
            url: '/some-endpoint',
        };
        const reply = {
            statusCode: 200,
        };
        const inputBody = {
            data: {
                id: 'some-id',
            },
        };
        const response = await (0, hooks_1.formatResponseHook)(req, reply, inputBody);
        expect(response).toStrictEqual({
            ...inputBody,
            links: { self: 'http://localhost/some-endpoint' },
        });
    });
    it('Should reply with a formatted array response', async () => {
        const req = {
            protocol: 'http',
            hostname: 'localhost',
            url: '/some-endpoint',
            query: {},
        };
        const reply = {
            statusCode: 200,
        };
        const inputBody = {
            data: [
                {
                    id: 'some-id',
                },
            ],
            total: 1,
        };
        const response = await (0, hooks_1.formatResponseHook)(req, reply, inputBody);
        expect(response).toStrictEqual({
            data: inputBody.data,
            page: {
                size: 20,
                number: 0,
                totalElements: 1,
                totalPages: 1,
            },
            links: {
                next: undefined,
                previous: undefined,
                self: 'http://localhost/some-endpoint?size=20',
            },
        });
    });
    it('Should reply with a formatted array response when result is empty', async () => {
        const req = {
            protocol: 'http',
            hostname: 'localhost',
            url: '/some-endpoint',
            query: {},
        };
        const reply = {
            statusCode: 200,
        };
        const inputBody = {
            data: [],
            total: 0,
        };
        const response = await (0, hooks_1.formatResponseHook)(req, reply, inputBody);
        expect(response).toStrictEqual({
            data: inputBody.data,
            page: {
                size: 20,
                number: 0,
                totalElements: 0,
                totalPages: 0,
            },
            links: {
                next: undefined,
                previous: undefined,
                self: 'http://localhost/some-endpoint?size=20',
            },
        });
    });
    it('Should throw an error when provided with a string as data type', async () => {
        const req = {};
        const reply = {
            statusCode: 200,
        };
        const inputBody = {
            data: 'invalid-input-data',
        };
        await expect((0, hooks_1.formatResponseHook)(req, reply, inputBody)).rejects.toThrow();
    });
    it('Should throw an error when provided with a number as data field', async () => {
        const req = {};
        const reply = {
            statusCode: 200,
        };
        const inputBody = {
            data: 5,
        };
        await expect((0, hooks_1.formatResponseHook)(req, reply, inputBody)).rejects.toThrow();
    });
    it('Should throw an error when called without a data field', async () => {
        const req = {};
        const reply = {
            statusCode: 200,
        };
        const inputBody = {
            invalidField: { id: 'some-id' },
        };
        await expect((0, hooks_1.formatResponseHook)(req, reply, inputBody)).rejects.toThrow();
    });
});
// describe("Rate limit hooks", () => {
//   const ip = "48.51.15.188";
//   const routerPath = "/some-endpoint";
//   const reply = {} as any;
//   test("Should not throw error for an authenticated user calling hook repeatedly", async () => {
//     const req = {
//       userContext: {
//         isAuthorizedUser: () => true,
//       },
//       ip,
//       routerPath,
//     } as any;
//     const lockPeriod = "5s";
//     await expect(
//       rateLimitByIpHook(req, reply, lockPeriod)
//     ).resolves.not.toThrowError();
//     await expect(
//       rateLimitByIpHook(req, reply, lockPeriod)
//     ).resolves.toBeUndefined();
//   });
//   test("Should throw an error for an anoymous user calling hook repeatedly before lock period ends", async () => {
//     const req = {
//       userContext: {
//         isAuthorizedUser: () => false,
//       },
//       ip,
//       routerPath,
//     } as any;
//     const lockPeriod = "5s";
//     await expect(
//       rateLimitByIpHook(req, reply, lockPeriod)
//     ).resolves.not.toThrowError();
//     await expect(rateLimitByIpHook(req, reply, lockPeriod)).rejects.toThrow(
//       new RateExceededError("Rate limit exceeded")
//     );
//   });
//   test("Should not throw an error for an anoymous user calling hook repeatedly after lock period ends", async () => {
//     const req = {
//       userContext: {
//         isAuthorizedUser: () => false,
//       },
//       ip,
//       routerPath,
//     } as any;
//     const lockPeriod = "1s";
//     await expect(
//       rateLimitByIpHook(req, reply, lockPeriod)
//     ).resolves.not.toThrowError();
//     // wait for key to expire
//     await new Promise((resolve) => setTimeout(resolve, 1500));
//     await expect(
//       rateLimitByIpHook(req, reply, lockPeriod)
//     ).resolves.not.toThrowError();
//   });
//   test("Should throw an error for a malformed lockPeriod", async () => {
//     const req = {
//       userContext: {
//         isAuthorizedUser: () => false,
//       },
//       ip,
//       routerPath,
//     } as any;
//     const lockPeriod = "boom";
//     await expect(
//       rateLimitByIpHook(req, reply, lockPeriod)
//     ).rejects.toThrowError();
//   });
// });
//# sourceMappingURL=hooks.test.js.map