"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.injectContextHook = exports.formatResponseHook = exports.errorHandler = void 0;
const context_1 = require("../../models/context");
const formatters_1 = require("./formatters");
const errorHandler = async (error, req, reply) => {
    const statusCode = error.statusCode || 500;
    if (error.validation) {
        return reply.status(statusCode).send({
            errors: error.validation,
        });
    }
    // We don't want to propagate 500 errors back to the client
    // They tend to include stack traces
    if (statusCode >= 500) {
        reply.status(statusCode).send({
            errors: [{ message: "Internal Server Error" }],
        });
    }
    return reply.status(statusCode).send({
        errors: [{ message: error.message }],
    });
};
exports.errorHandler = errorHandler;
const formatResponseHook = async (req, reply, body) => {
    // Special case is status code 204, 404 and redirect responses, in which we expect an empty response
    if (reply.statusCode === 204 || reply.statusCode >= 300) {
        return undefined;
    }
    if (body.data instanceof Array && body.total != undefined) {
        return (0, formatters_1.asArrayResponse)(req, body.data, body.total);
    }
    if (body.data instanceof Object) {
        return (0, formatters_1.asObjectResponse)(req, body.data);
    }
    throw new Error("Poorly formatted response. Expected ArrayReply or ObjectReply.");
};
exports.formatResponseHook = formatResponseHook;
const injectContextHook = async (req, reply) => {
    if (req.cookies?.access_token) {
        req.userContext = context_1.Context.fromCookie(req.cookies.access_token);
    }
    else if (req.headers.authorization) {
        req.userContext = context_1.Context.fromHeaders(req.headers);
    }
    else {
        req.userContext = new context_1.AnonymousContext();
    }
    req.getContext = () => req.userContext;
};
exports.injectContextHook = injectContextHook;
// We need redis for this - because of cost of running
// redis, we'll disable it for now
// This rate limiter gets added on a per route basis in our micro services
// export const rateLimitByIpHook = async (
//   req: FastifyRequest,
//   reply: FastifyReply,
//   lockPeriod: string
// ) => {
//   if (req.userContext.isAuthorizedUser()) {
//     return;
//   }
//   const { ip: sourceIp, routerPath } = req;
//   const ipHash = crypto.createHash("sha256").update(sourceIp).digest("base64");
//   const redisKey = `rateLimitLock::${routerPath}::${ipHash}`;
//   try {
//     // if the key is present we are still within the lock period
//     const existingKey = await IORedis.sharedInstance().get(redisKey);
//     if (existingKey) {
//       throw new RateExceededError("Rate limit exceeded");
//     }
//     // add the key with the lock period as a timeout for future calls
//     await IORedis.sharedInstance().setex(
//       redisKey,
//       ms(lockPeriod) / 1000,
//       `lock is set for ${routerPath}`
//     );
//   } catch (err) {
//     if (err instanceof RateExceededError) {
//       logger.warn({
//         msg: err.message,
//         sourceIp,
//         routerPath,
//       });
//     } else {
//       logger.error({
//         message: "error checking rate limit lock",
//         err,
//         sourceIp,
//         routerPath,
//       });
//     }
//     throw err;
//   }
// };
//# sourceMappingURL=hooks.js.map