declare const SUFFIX = "Async";
type LastIndex<T extends readonly any[]> = ((...t: T) => void) extends (x: any, ...r: infer R) => void ? Exclude<keyof T, keyof R> : never;
type AtLastIndex<F> = F extends (...args: infer T) => any ? T[LastIndex<T>] extends Exclude<any, undefined> ? Exclude<T[LastIndex<T>], undefined> : never : never;
type Tail<T extends any[]> = ((...t: T) => void) extends (h: any, ...r: infer R) => void ? R : never;
type Last<T extends any[]> = T[Exclude<keyof T, keyof Tail<T>>];
type LastParameter<F extends (...args: any) => any> = Last<Parameters<F>>;
type Wrap<T, Callback> = {
    [K in keyof T]-?: [Exclude<T[K], Callback>];
};
type Unwrap<T> = {
    [K in keyof T]: Extract<T[K], [any]>[0];
};
type InitialParameters<F extends (...args: any) => any, Callback> = Wrap<Parameters<F>, Callback> extends [...infer InitPs, any] ? Unwrap<InitPs> : never;
type Promisified<F> = F extends (...args: infer T) => any ? AtLastIndex<F> extends (...args: any) => any ? (...args: InitialParameters<F, AtLastIndex<F>>) => AtLastIndex<F> extends (...args: any) => any ? Promise<LastParameter<AtLastIndex<F>>> : never : null : never;
type OmitNever<T> = {
    [K in keyof T as T[K] extends never ? never : K]: T[K];
};
type NotFunc<T> = Exclude<T, Function>;
type PromisifiedClassMethods<T extends object> = {
    [K in keyof T as K extends `${infer P}${typeof SUFFIX}` ? `${P}${typeof SUFFIX}` : T[K] extends NotFunc<T[K]> ? never : `${Extract<K, string>}${typeof SUFFIX}`]: Promisified<T[K]>;
} extends infer O ? {
    [K in keyof O]: O[K];
} : never;
export declare function promisifyAll<T extends object>(obj: T, filter?: (name: string, value: unknown, obj: T, passesDefaultFilter: boolean) => boolean): T & OmitNever<PromisifiedClassMethods<T>>;
export {};
