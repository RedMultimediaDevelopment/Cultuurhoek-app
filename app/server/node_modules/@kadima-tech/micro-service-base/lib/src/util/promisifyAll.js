"use strict";
/* eslint-disable @typescript-eslint/ban-types */
// The Function type is necessary in this file,
Object.defineProperty(exports, "__esModule", { value: true });
exports.promisifyAll = void 0;
/**
 * This code is largely adopted from Bluebird.js, but extended with Typescript support
 * and native promises
 */
const util_1 = require("util");
const SUFFIX = 'Async';
const escapeIdentRegex = function (str) {
    return str.replace(/([$])/, '\\$');
};
const rident = /^[a-z$_][a-z$_0-9]*$/i;
function isIdentifier(str) {
    return rident.test(str);
}
const defaultFilter = function (name) {
    return isIdentifier(name) && name.charAt(0) !== '_' && name !== 'constructor';
};
function isPrimitive(val) {
    return (val == null ||
        val === true ||
        val === false ||
        typeof val === 'string' ||
        typeof val === 'number');
}
const inheritedDataKeys = (function () {
    const excludedPrototypes = [
        Array.prototype,
        Object.prototype,
        Function.prototype,
    ];
    const isExcludedProto = function (val) {
        for (let i = 0; i < excludedPrototypes.length; ++i) {
            if (excludedPrototypes[i] === val) {
                return true;
            }
        }
        return false;
    };
    const getPrototypeOf = function (obj) {
        try {
            return Object(obj).constructor.prototype;
        }
        catch (e) {
            return {}.constructor.prototype;
        }
    };
    const hasProp = {}.hasOwnProperty;
    return function (obj) {
        if (isExcludedProto(obj)) {
            return [];
        }
        const ret = [];
        const keys = Object.getOwnPropertyNames(getPrototypeOf(obj));
        /*jshint forin:false */
        enumeration: for (const key of keys) {
            if (hasProp.call(obj, key)) {
                ret.push(key);
            }
            else {
                for (let i = 0; i < excludedPrototypes.length; ++i) {
                    if (hasProp.call(excludedPrototypes[i], key)) {
                        continue enumeration;
                    }
                }
                ret.push(key);
            }
        }
        return ret;
    };
})();
function notEnumerableProp(obj, name, value) {
    if (isPrimitive(obj)) {
        return obj;
    }
    const descriptor = {
        value,
        configurable: true,
        enumerable: false,
        writable: true,
    };
    return {
        ...obj,
        [name]: descriptor,
    };
}
function checkValid(ret, suffix, suffixRegexp) {
    // Verify that in the list of methods to promisify there is no
    // method that has a name ending in "Async"-suffix while
    // also having a method with the same name but no Async suffix
    for (let i = 0; i < ret.length; i += 2) {
        const key = ret[i];
        if (suffixRegexp.test(key)) {
            const keyWithoutAsyncSuffix = key.replace(suffixRegexp, '');
            for (let j = 0; j < ret.length; j += 2) {
                if (ret[j] === keyWithoutAsyncSuffix) {
                    throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix".replace('%s', suffix));
                }
            }
        }
    }
}
function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
    const defaultPromisified = { __isPromisified__: true };
    function isPromisified(fn) {
        try {
            return fn.__isPromisified__ === true;
        }
        catch (e) {
            return false;
        }
    }
    function getDataPropertyOrDefault(obj, key, defaultValue) {
        const desc = Object.getOwnPropertyDescriptor(obj, key);
        if (desc != null) {
            return desc.get == null && desc.set == null ? desc.value : defaultValue;
        }
    }
    function hasPromisified(obj, key, suffix) {
        const val = getDataPropertyOrDefault(obj, key + suffix, defaultPromisified);
        return val ? isPromisified(val) : false;
    }
    const keys = inheritedDataKeys(obj);
    const ret = [];
    for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        const value = obj[key];
        const passesDefaultFilter = filter === defaultFilter ? true : defaultFilter(key);
        if (typeof value === 'function' &&
            !isPromisified(value) &&
            !hasPromisified(obj, key, suffix) &&
            filter(key, value, obj, passesDefaultFilter)) {
            ret.push(key, value);
        }
    }
    checkValid(ret, suffix, suffixRegexp);
    return ret;
}
function promisifyAll(obj, filter = defaultFilter) {
    const resultingInstance = obj;
    const suffixRegexp = new RegExp(escapeIdentRegex(SUFFIX) + '$');
    const methods = promisifiableMethods(obj, SUFFIX, suffixRegexp, filter);
    for (let i = 0, len = methods.length; i < len; i += 2) {
        const key = methods[i];
        const fn = methods[i + 1];
        const promisifiedKey = `${key}${SUFFIX}`;
        const promisified = (0, util_1.promisify)(fn).bind(obj);
        notEnumerableProp(promisified, '__isPromisified__', true);
        if (resultingInstance[key]) {
            resultingInstance[promisifiedKey] = promisified;
        }
    }
    return resultingInstance;
}
exports.promisifyAll = promisifyAll;
//# sourceMappingURL=promisifyAll.js.map