"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const promisifyAll_1 = require("./promisifyAll");
describe('Promisifying class method', () => {
    it('Should make an `Async` method available for a class', async () => {
        const dataToReturn = 'Hello';
        class MyClass {
            fnWithCallback(callback) {
                callback(null, dataToReturn);
            }
        }
        const myClassInstance = new MyClass();
        const promisified = (0, promisifyAll_1.promisifyAll)(myClassInstance);
        await expect(promisified.fnWithCallbackAsync()).resolves.toBe(dataToReturn);
    });
    it('Should be able to promisify the same object twice without issue', async () => {
        const dataToReturn = 'Hello';
        class MyClass {
            fnWithCallback(callback) {
                callback(null, dataToReturn);
            }
        }
        const myClassInstance = new MyClass();
        const promisified = (0, promisifyAll_1.promisifyAll)((0, promisifyAll_1.promisifyAll)(myClassInstance));
        await expect(promisified.fnWithCallbackAsync()).resolves.toBe(dataToReturn);
    });
    it('The original callback function should still work', async () => {
        const dataToReturn = 'Hello';
        class MyClass {
            fnWithCallback(callback) {
                callback(null, dataToReturn);
            }
        }
        const myClassInstance = new MyClass();
        const promisified = (0, promisifyAll_1.promisifyAll)(myClassInstance);
        await expect(new Promise((resolve) => promisified.fnWithCallback((err, res) => resolve(res)))).resolves.toBe(dataToReturn);
    });
    it('Should correctly handle typed responses', async () => {
        const dataToReturn = 2;
        class MyClass {
            fnWithCallback(callback) {
                callback(null, dataToReturn);
            }
        }
        const myClassInstance = new MyClass();
        const promisified = (0, promisifyAll_1.promisifyAll)(myClassInstance);
        await expect(promisified.fnWithCallbackAsync()).resolves.toBe(dataToReturn);
    });
    it('Should have this scope access', async () => {
        class MyClass {
            constructor() {
                this.test = 'a';
            }
            setMyVariable(myVar) {
                this.somevariable = myVar;
            }
            fnWithCallback(callback) {
                callback(null, this.somevariable);
            }
        }
        const myClassInstance = new MyClass();
        myClassInstance.setMyVariable('hello');
        const promisified = (0, promisifyAll_1.promisifyAll)(myClassInstance);
        await expect(promisified.fnWithCallbackAsync()).resolves.toBe('hello');
    });
    it('Should handle errors correctly', async () => {
        class MyClass {
            fnWithCallback(callback) {
                callback(new Error('ERROR'));
            }
        }
        const myClassInstance = new MyClass();
        const promisified = (0, promisifyAll_1.promisifyAll)(myClassInstance);
        await expect(promisified.fnWithCallbackAsync()).rejects.toThrow();
    });
    it('Should handle complex types correctly', async () => {
        class MyComplexClass {
            getProjectById(input, metadata, options, callback) {
                if (callback) {
                    callback(null, input);
                }
            }
        }
        const myClassInstance = new MyComplexClass();
        const promisified = (0, promisifyAll_1.promisifyAll)(myClassInstance);
        await expect(promisified.getProjectByIdAsync('a', {}, undefined)).resolves.toBe('a');
    });
});
//# sourceMappingURL=promisifyAll.test.js.map