"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const pg_listen_1 = __importDefault(require("pg-listen"));
const postgres_1 = require("./postgres");
jest.mock('pg', () => {
    const mClient = {
        connect: jest.fn(),
        query: jest.fn(),
        end: jest.fn(),
    };
    return {
        Client: jest.fn((_config) => {
            return { ...mClient, uri: _config.connectionString };
        }),
    };
});
const pgListenMock = {
    events: { on: jest.fn() },
    connect: jest.fn(),
};
jest.mock('pg-listen', () => jest.fn(() => pgListenMock));
let pEnvState = {};
beforeEach(() => {
    jest.resetModules();
    pEnvState = { ...process.env };
});
afterEach(() => {
    jest.clearAllMocks();
    process.env = { ...pEnvState };
});
describe('getPostgresClient - Should construct a pg client', () => {
    it('Should construct a postgres client using sensible defaults', async () => {
        const client = (0, postgres_1.getPostgresClient)();
        expect(client.uri).toBe('postgresql://postgres:mysecretpassword@localhost:5432/postgres');
    });
    it('Should construct a postgres client with the available variables [DATABASE_HOST]', async () => {
        process.env.DATABASE_HOST = 'mushroomkingdom:5432';
        const client = (0, postgres_1.getPostgresClient)();
        expect(client.uri).toBe('postgresql://postgres:mysecretpassword@mushroomkingdom:5432/postgres');
    });
    it('Should construct a postgres client with the available variables [DATABASE_USER]', async () => {
        process.env.DATABASE_USER = 'johnny';
        const client = (0, postgres_1.getPostgresClient)();
        expect(client.uri).toBe('postgresql://johnny:mysecretpassword@localhost:5432/postgres');
    });
    it('Should construct a postgres client with the available variables [DATABASE_PASSWORD]', async () => {
        process.env.DATABASE_PASSWORD = 'mynotsosecretpassword';
        const client = (0, postgres_1.getPostgresClient)();
        expect(client.uri).toBe('postgresql://postgres:mynotsosecretpassword@localhost:5432/postgres');
    });
    it('Should construct a postgres client with the available variables [DATABASE_NAME]', async () => {
        process.env.DATABASE_NAME = 'awesomedb';
        const client = (0, postgres_1.getPostgresClient)();
        expect(client.uri).toBe('postgresql://postgres:mysecretpassword@localhost:5432/awesomedb');
    });
    it('Should use the provided DATABASE_URL to setup the client', async () => {
        process.env.DATABASE_URL = 'mycustomdburl';
        const client = (0, postgres_1.getPostgresClient)();
        expect(client.uri).toBe('mycustomdburl');
    });
    it('Should use the provided url option to create the db url', async () => {
        process.env.DATABASE_URL = 'mycustomdburl';
        const client = (0, postgres_1.getPostgresClient)({
            connectionString: 'myurl',
        });
        expect(client.uri).toBe('myurl');
    });
});
describe('getPostgresSubscriber', () => {
    it('should pass the connection options to pg-listen and call connect', async () => {
        await (0, postgres_1.getPostgresSubscriber)();
        expect(pg_listen_1.default).toHaveBeenCalledWith({
            connectionString: 'postgresql://postgres:mysecretpassword@localhost:5432/postgres',
        }, undefined);
        expect(pgListenMock.connect).toHaveBeenCalled();
    });
    it('should pass the provided URL and options to pg-listen', async () => {
        await (0, postgres_1.getPostgresSubscriber)({ connectionString: 'url' }, { paranoidChecking: 10 });
        expect(pg_listen_1.default).toHaveBeenCalledWith({ connectionString: 'url' }, { paranoidChecking: 10 });
        expect(pgListenMock.connect).toHaveBeenCalled();
    });
});
//# sourceMappingURL=postgres.test.js.map