"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const jsonwebtoken_1 = __importDefault(require("jsonwebtoken"));
const errors_1 = require("../errors");
const context_1 = require("./context");
const mockHeaders = ({ userId = '5ce0b6b9-1077-4b51-9539-6a74606bd3b4', userRoles = ['TEST'], features = undefined, scopes = undefined, } = {}) => {
    const authHeader = jsonwebtoken_1.default.sign({ sub: userId, roles: userRoles, features, scopes }, 'secret');
    return {
        authorization: authHeader,
    };
};
describe('Context', () => {
    it('Should set the user role and user id properties according to the provided headers', () => {
        const userId = '5e2b5ff2-5002-47e5-a212-8566a1745278';
        const userRoles = ['ADMIN'];
        const headers = mockHeaders({ userId, userRoles });
        const ctx = context_1.Context.fromHeaders(headers);
        expect(ctx.userId).toBe(userId);
        expect(ctx.userRoles).toStrictEqual(userRoles);
    });
    it('HasRole should return true if the user has the supplied role', () => {
        const userId = '5e2b5ff2-5002-47e5-a212-8566a1745278';
        const userRoles = ['ADMIN'];
        const headers = mockHeaders({ userId, userRoles });
        const ctx = context_1.Context.fromHeaders(headers);
        expect(ctx.hasRole('ADMIN')).toBe(true);
    });
    it('HasRole should return false if the user does not have the supplied role', () => {
        const userId = '5e2b5ff2-5002-47e5-a212-8566a1745278';
        const userRoles = ['ADMIN'];
        const headers = mockHeaders({ userId, userRoles });
        const ctx = context_1.Context.fromHeaders(headers);
        expect(ctx.hasRole('NOT_ADMIN')).toBe(false);
    });
    it('FromCookie should throw an unauthorised exception if the cookie is not a valid json', () => {
        expect(() => {
            context_1.Context.fromCookie('bleugh');
        }).toThrow(errors_1.UnauthorizedError);
    });
    it('FromCookie should throw an unauthorised exception if the cookie is valid json but not a jwt', () => {
        expect(() => {
            context_1.Context.fromCookie('{ hi: bob }');
        }).toThrow(errors_1.UnauthorizedError);
    });
    it('FromHeader should throw an unauthorised exception if the auth header is not a valid json', () => {
        expect(() => {
            context_1.Context.fromHeaders({ authorization: 'bleugh' });
        }).toThrow(errors_1.UnauthorizedError);
    });
    it('FromHeader should throw an unauthorised exception if the auth header is valid json but not a jwt', () => {
        expect(() => {
            context_1.Context.fromHeaders({
                authorization: '{ hi: bob }',
            });
        }).toThrow(errors_1.UnauthorizedError);
    });
    describe('getUserId', () => {
        it('getUserId should return user ID', () => {
            const ctx = context_1.Context.fromHeaders(mockHeaders({ userId: 'userId' }));
            expect(ctx.getUserId()).toEqual('userId');
        });
        it('getUserId should return null for anonymous context', () => {
            const ctx = new context_1.AnonymousContext();
            expect(ctx.getUserId()).toBeNull();
        });
    });
    describe('scopes', () => {
        it('returns false from an anonymous context', () => {
            const ctx = new context_1.AnonymousContext();
            expect(ctx.hasScope('admin')).toBe(false);
        });
        it('return true if a scope is available', () => {
            const ctx = context_1.Context.fromHeaders(mockHeaders({
                userId: 'userId',
                features: undefined,
                scopes: ['admin'],
            }));
            expect(ctx.hasScope('admin')).toBe(true);
        });
        it('return false when the scope is not in the scopes array', () => {
            const ctx = context_1.Context.fromHeaders(mockHeaders({
                userId: 'userId',
                features: undefined,
                scopes: ['profile'],
            }));
            expect(ctx.hasScope('admin')).toBe(false);
        });
        it('return false when a scopes array is not provided', () => {
            const ctx = context_1.Context.fromHeaders(mockHeaders({
                userId: 'userId',
                features: undefined,
                scopes: undefined,
            }));
            expect(ctx.hasScope('admin')).toBe(false);
        });
    });
    describe('featureFlagEnabled', () => {
        it('returns false from an anonymous context', () => {
            const ctx = new context_1.AnonymousContext();
            expect(ctx.featureFlagEnabled('anything')).toBe(false);
        });
        it('return false when no features are available', () => {
            const ctx = context_1.Context.fromHeaders(mockHeaders({ userId: 'userId', features: undefined }));
            expect(ctx.featureFlagEnabled('onFeature')).toBe(false);
        });
        it('return false when the requested feature doesnt exist', () => {
            const ctx = context_1.Context.fromHeaders(mockHeaders({
                userId: 'userId',
                features: {
                    aFeature: true,
                },
            }));
            expect(ctx.featureFlagEnabled('unknownFeature')).toBe(false);
        });
        it('return false when the requested feature exists but is disabled', () => {
            const ctx = context_1.Context.fromHeaders(mockHeaders({
                userId: 'userId',
                features: {
                    offFeature: false,
                },
            }));
            expect(ctx.featureFlagEnabled('offFeature')).toBe(false);
        });
        it('return true when the requested feature exists and is enabled', () => {
            const ctx = context_1.Context.fromHeaders(mockHeaders({
                userId: 'userId',
                features: {
                    onFeature: true,
                },
            }));
            expect(ctx.featureFlagEnabled('onFeature')).toBe(true);
        });
    });
});
//# sourceMappingURL=context.test.js.map